{"name": "Black-Scholes", "description": "Black-Scholes\n", "created": "2017-07-15T16:20:53.864856", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy implementation", "source": "\nfrom __future__ import print_function\n\nimport numpy as np\n\n\ndef cnd(d):\n    A1 = 0.31938153\n    A2 = -0.356563782\n    A3 = 1.781477937\n    A4 = -1.821255978\n    A5 = 1.330274429\n    RSQRT2PI = 0.39894228040143267793994605993438\n    K = 1.0 / (1.0 + 0.2316419 * np.abs(d))\n    ret_val = (RSQRT2PI * np.exp(-0.5 * d * d) *\n               (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5))))))\n    return np.where(d > 0, 1.0 - ret_val, ret_val)\n\n    # SPEEDTIP: Despite the memory overhead and redundant computation, the above\n    # is much faster than:\n    #\n    # for i in range(len(d)):\n    #     if d[i] > 0:\n    #         ret_val[i] = 1.0 - ret_val[i]\n    # return ret_val\n\n\ndef black_scholes(stockPrice, optionStrike, optionYears, Riskfree, Volatility):\n    S = stockPrice\n    X = optionStrike\n    T = optionYears\n    R = Riskfree\n    V = Volatility\n    sqrtT = np.sqrt(T)\n    d1 = (np.log(S / X) + (R + 0.5 * V * V) * T) / (V * sqrtT)\n    d2 = d1 - V * sqrtT\n    cndd1 = cnd(d1)\n    cndd2 = cnd(d2)\n\n    expRT = np.exp(- R * T)\n\n    callResult = S * cndd1 - X * expRT * cndd2\n    putResult = X * expRT * (1.0 - cndd2) - S * (1.0 - cndd1)\n\n    return callResult, putResult\n"}, {"name": "numba", "description": "Numba implementation", "source": "import math\n\nimport numpy as np\n\nfrom numba import jit\n\n\n@jit\ndef cnd_numba(d):\n    A1 = 0.31938153\n    A2 = -0.356563782\n    A3 = 1.781477937\n    A4 = -1.821255978\n    A5 = 1.330274429\n    RSQRT2PI = 0.39894228040143267793994605993438\n    K = 1.0 / (1.0 + 0.2316419 * math.fabs(d))\n    ret_val = (RSQRT2PI * math.exp(-0.5 * d * d) *\n               (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5))))))\n    if d > 0:\n        ret_val = 1.0 - ret_val\n    return ret_val\n\n\n@jit\ndef black_scholes_numba(stockPrice, optionStrike,\n                        optionYears, Riskfree, Volatility):\n    callResult = np.empty_like(stockPrice)\n    putResult = np.empty_like(stockPrice)\n\n    S = stockPrice\n    X = optionStrike\n    T = optionYears\n    R = Riskfree\n    V = Volatility\n    for i in range(len(S)):\n        sqrtT = math.sqrt(T[i])\n        d1 = (math.log(S[i] / X[i]) + (R + 0.5 * V * V) * T[i]) / (V * sqrtT)\n        d2 = d1 - V * sqrtT\n        cndd1 = cnd_numba(d1)\n        cndd2 = cnd_numba(d2)\n\n        expRT = math.exp((-1. * R) * T[i])\n        callResult[i] = (S[i] * cndd1 - X[i] * expRT * cndd2)\n        putResult[i] = (X[i] * expRT * (1.0 - cndd2) - S[i] * (1.0 - cndd1))\n\n    return callResult, putResult\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "from __future__ import print_function\n\nimport math\nimport time\n\nimport numpy as np\n\nfrom numba import cuda\n\n\n@cuda.jit(device=True)\ndef cnd_cuda(d):\n    A1 = 0.31938153\n    A2 = -0.356563782\n    A3 = 1.781477937\n    A4 = -1.821255978\n    A5 = 1.330274429\n    RSQRT2PI = 0.39894228040143267793994605993438\n    K = 1.0 / (1.0 + 0.2316419 * math.fabs(d))\n    ret_val = (RSQRT2PI * math.exp(-0.5 * d * d) *\n               (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5))))))\n    if d > 0:\n        ret_val = 1.0 - ret_val\n    return ret_val\n\n\n@cuda.jit\ndef black_scholes_cuda_kernel(callResult, putResult, S, X,\n                       T, R, V):\n    #    S = stockPrice\n    #    X = optionStrike\n    #    T = optionYears\n    #    R = Riskfree\n    #    V = Volatility\n    i = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x\n    if i >= S.shape[0]:\n        return\n    sqrtT = math.sqrt(T[i])\n    d1 = (math.log(S[i] / X[i]) + (R + 0.5 * V * V) * T[i]) / (V * sqrtT)\n    d2 = d1 - V * sqrtT\n    cndd1 = cnd_cuda(d1)\n    cndd2 = cnd_cuda(d2)\n\n    expRT = math.exp((-1. * R) * T[i])\n    callResult[i] = (S[i] * cndd1 - X[i] * expRT * cndd2)\n    putResult[i] = (X[i] * expRT * (1.0 - cndd2) - S[i] * (1.0 - cndd1))\n\n\ndef black_scholes_cuda(stockPrice, optionStrike,\n                        optionYears, Riskfree, Volatility):\n\n    blockdim = 1024, 1\n    griddim = int(math.ceil(float(len(stockPrice))/blockdim[0])), 1\n\n    stream = cuda.stream()\n\n    d_callResult = cuda.device_array_like(stockPrice, stream)\n    d_putResult = cuda.device_array_like(stockPrice, stream)\n    d_stockPrice = cuda.to_device(stockPrice, stream)\n    d_optionStrike = cuda.to_device(optionStrike, stream)\n    d_optionYears = cuda.to_device(optionYears, stream)\n\n    black_scholes_cuda_kernel[griddim, blockdim, stream](\n            d_callResult, d_putResult, d_stockPrice, d_optionStrike,\n            d_optionYears, Riskfree, Volatility)\n    callResult = d_callResult.copy_to_host(stream=stream)\n    putResult= d_putResult.copy_to_host(stream=stream)\n    stream.synchronize()\n\n    return callResult, putResult\n"}], "results": [{"numpy": {"x": [1000, 100000, 1000000, 4000000], "times": [0.00021531355381011963, 0.034040484298020604, 0.14865550491958857, 0.5984987830743194]}, "numba": {"x": [1000, 100000, 1000000, 4000000], "times": [0.00011149581195786595, 0.01099299737252295, 0.10982692008838058, 0.4439954226836562]}, "numba_gpu": {"x": [1000, 100000, 1000000, 4000000], "times": [0.0013556619826704263, 0.0032736049499362705, 0.011075565405189992, 0.04101291699334979]}, "category": ["float64"]}, {"numpy": {"x": [1000, 100000, 1000000, 4000000], "times": [0.00027729538921266795, 0.006581963980570435, 0.06958779939450324, 0.3209060109220445]}, "numba": {"x": [1000, 100000, 1000000, 4000000], "times": [0.00010297541413456202, 0.010135059570893645, 0.10150058986619115, 0.4061483130790293]}, "numba_gpu": {"x": [1000, 100000, 1000000, 4000000], "times": [0.0013439698005095124, 0.0020316812582314016, 0.007901415722444653, 0.019310083193704485]}, "category": ["float32"]}]}
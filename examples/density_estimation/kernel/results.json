{"name": "Kernel Density Estimator", "description": "Evaluate a 1D Gaussian [kernel density estimator](https://en.wikipedia.org/wiki/Kernel_density_estimation) \nat a list of points given a list of samples from the distribution and corresponding kernel bandwidths.\n", "created": "2017-07-24T17:34:02.147117", "xlabel": "Number of evaluation points", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_kde(eval_points, samples, bandwidths):\n    # This uses a lot of RAM and doesn't scale to larger datasets\n    rescaled_x = (eval_points[:, np.newaxis] - samples[np.newaxis, :]) / bandwidths[np.newaxis, :]\n    gaussian = np.exp(-0.5 * rescaled_x**2) / np.sqrt(2 * np.pi) / bandwidths[np.newaxis, :]\n    return gaussian.sum(axis=1) / len(samples)\n\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n@numba.jit(nopython=True)\ndef gaussian(x):\n    return np.exp(-0.5 * x**2) / np.sqrt(2 * np.pi)\n\n@numba.jit(nopython=True)\ndef numba_kde(eval_points, samples, bandwidths):\n    result = np.zeros_like(eval_points)\n\n    for i, eval_x in enumerate(eval_points):\n        for sample, bandwidth in zip(samples, bandwidths):\n            result[i] += gaussian((eval_x - sample) / bandwidth) / bandwidth\n        result[i] /= len(samples)\n\n    return result\n"}, {"name": "numba_multithread", "description": "Numba multi-threaded", "source": "\nimport numba\nimport numpy as np\n\n@numba.jit(nopython=True, parallel=True)\ndef numba_kde_multithread(eval_points, samples, bandwidths):\n    result = np.zeros_like(eval_points)\n\n    # SPEEDTIP: Parallelize over evaluation points with prange()\n    for i in numba.prange(len(eval_points)):\n        eval_x = eval_points[i]\n        for sample, bandwidth in zip(samples, bandwidths):\n            result[i] += gaussian((eval_x - sample) / bandwidth) / bandwidth\n        result[i] /= len(samples)\n\n    return result\n"}], "results": [{"numpy": {"x": [10, 1000, 10000], "times": [0.0008520041569136084, 0.08142308690585195, 0.2921812040731311]}, "numba": {"x": [10, 1000, 10000], "times": [0.00023610624484717845, 0.02366552213206887, 0.24088259506970644]}, "numba_multithread": {"x": [10, 1000, 10000], "times": [0.00047045246697962283, 0.02159921918064356, 0.1888548107817769]}, "category": ["samples1000", "float64"]}, {"numpy": {"x": [10, 1000, 10000], "times": [0.002463256870396435, 0.27447703713551164, 2.7811449728906155]}, "numba": {"x": [10, 1000, 10000], "times": [0.00238551857881248, 0.2360268160700798, 2.3633399880491197]}, "numba_multithread": {"x": [10, 1000, 10000], "times": [0.004591026520356536, 0.18897432228550315, 1.9027303662151098]}, "category": ["samples10000", "float64"]}]}
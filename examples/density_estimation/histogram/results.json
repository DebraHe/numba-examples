{"name": "Histogram", "description": "Compute a 1D histogram over elements from an input array.  Note that these\nNumba implementations do not cover all the options that numpy.histogram allows.\n", "created": "2017-07-15T16:27:14.504106", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_histogram(a, bins):\n    return np.histogram(a, bins)\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, bins):\n    bin_edges = np.zeros((bins+1,), dtype=np.float64)\n    a_min = a.min()\n    a_max = a.max()\n    delta = (a_max - a_min) / bins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\n@numba.jit(nopython=True)\ndef compute_bin(x, bin_edges):\n    # assuming uniform bins for now\n    n = bin_edges.shape[0] - 1\n    a_min = bin_edges[0]\n    a_max = bin_edges[-1]\n\n    # special case to mirror NumPy behavior for last bin\n    if x == a_max:\n        return n - 1 # a_max always in last bin\n\n    bin = int(n * (x - a_min) / (a_max - a_min))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n\n@numba.jit(nopython=True)\ndef numba_histogram(a, bins):\n    hist = np.zeros((bins,), dtype=np.intp)\n    bin_edges = get_bin_edges(a, bins)\n\n    for x in a.flat:\n        bin = compute_bin(x, bin_edges)\n        if bin is not None:\n            hist[int(bin)] += 1\n\n    return hist, bin_edges\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "import numpy as np\n\nimport numba\nfrom numba import cuda\n\n@numba.jit(nopython=True)\ndef compute_bin(x, n, xmin, xmax):\n    # special case to mirror NumPy behavior for last bin\n    if x == xmax:\n        return n - 1 # a_max always in last bin\n\n    # SPEEDTIP: Remove the float64 casts if you don't need to exactly reproduce NumPy\n    bin = np.int32(n * (np.float64(x) - np.float64(xmin)) / (np.float64(xmax) - np.float64(xmin)))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n@cuda.jit\ndef histogram(x, xmin, xmax, histogram_out):\n    nbins = histogram_out.shape[0]\n    bin_width = (xmax - xmin) / nbins\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    for i in range(start, x.shape[0], stride):\n        # note that calling a numba.jit function from CUDA automatically\n        # compiles an equivalent CUDA device function!\n        bin_number = compute_bin(x[i], nbins, xmin, xmax)\n\n        if bin_number >= 0 and bin_number < histogram_out.shape[0]:\n            cuda.atomic.add(histogram_out, bin_number, 1)\n\n@cuda.jit\ndef min_max(x, min_max_array):\n    nelements = x.shape[0]\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    # Array already seeded with starting values appropriate for x's dtype\n    # Not a problem if this array has already been updated\n    local_min = min_max_array[0]\n    local_max = min_max_array[1]\n\n    for i in range(start, x.shape[0], stride):\n        element = x[i]\n        local_min = min(element, local_min)\n        local_max = max(element, local_max)\n\n    # Now combine each thread local min and max\n    cuda.atomic.min(min_max_array, 0, local_min)\n    cuda.atomic.max(min_max_array, 1, local_max)\n\n\ndef dtype_min_max(dtype):\n    '''Get the min and max value for a numeric dtype'''\n    if np.issubdtype(dtype, np.integer):\n        info = np.iinfo(dtype)\n    else:\n        info = np.finfo(dtype)\n    return info.min, info.max\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, nbins, a_min, a_max):\n    bin_edges = np.empty((nbins+1,), dtype=np.float64)\n    delta = (a_max - a_min) / nbins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\ndef numba_gpu_histogram(a, bins):\n    # Move data to GPU so we can do two operations on it\n    a_gpu = cuda.to_device(a)\n\n    ### Find min and max value in array\n    dtype_min, dtype_max = dtype_min_max(a.dtype)\n    # Put them in the array in reverse order so that they will be replaced by the first element in the array\n    min_max_array_gpu = cuda.to_device(np.array([dtype_max, dtype_min], dtype=a.dtype))\n    min_max[64, 64](a_gpu, min_max_array_gpu)\n    a_min, a_max = min_max_array_gpu.copy_to_host()\n\n    # SPEEDTIP: Skip this step if you don't need to reproduce the NumPy histogram edge array\n    bin_edges = get_bin_edges(a, bins, a_min, a_max) # Doing this on CPU for now\n\n    ### Bin the data into a histogram \n    histogram_out = cuda.to_device(np.zeros(shape=(bins,), dtype=np.int32))\n    histogram[64, 64](a_gpu, a_min, a_max, histogram_out)\n\n    return histogram_out.copy_to_host(), bin_edges\n"}], "results": [{"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015086135268211365, 0.0002626048969104886, 0.0012508694268763066, 0.0034455204987898468, 0.03481967221014202]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.612813100218773e-06, 5.6289150472730395e-05, 0.0005563282649964094, 0.001664559179916978, 0.016722869500517844]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0010577856190502643, 0.0012247003614902496, 0.0012962456094101071, 0.0019323396170511842, 0.0049559478461742405]}, "category": ["bins10", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001459057410247624, 0.00025489743193611504, 0.0013164799381047488, 0.003599228812381625, 0.03722609607502818]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.706920401193201e-06, 5.594957610592246e-05, 0.00055100566893816, 0.0016595425317063929, 0.016709409188479185]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012715377332642675, 0.001281453291885555, 0.0015411030687391759, 0.002070021191611886, 0.007154868980869651]}, "category": ["bins10", "float64"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001694949697703123, 0.00027208833023905754, 0.001267788391560316, 0.003446035608649254, 0.0345152101945132]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.923523606732488e-06, 5.861498918384314e-05, 0.0005622788262553513, 0.0016793288290500642, 0.016808861587196588]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012276517506688833, 0.00138241995126009, 0.0014284937409684063, 0.0019965851260349155, 0.004571378980763256]}, "category": ["bins1000", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015652930689975618, 0.0002652390720322728, 0.0013225481612607836, 0.003611003551632166, 0.037107109930366276]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.964020320214331e-06, 5.73999494779855e-05, 0.000558957145549357, 0.001679284768179059, 0.01682250271551311]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0013776951609179378, 0.0013875165907666087, 0.001632147221826017, 0.002160856178961694, 0.006657278328202665]}, "category": ["bins1000", "float64"]}]}
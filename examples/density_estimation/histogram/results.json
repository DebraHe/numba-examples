{"name": "Histogram", "description": "Compute a 1D histogram over elements from an input array.  Note that these\nNumba implementations do not cover all the options that numpy.histogram allows.\n", "created": "2017-07-24T17:32:53.000798", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_histogram(a, bins):\n    return np.histogram(a, bins)\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, bins):\n    bin_edges = np.zeros((bins+1,), dtype=np.float64)\n    a_min = a.min()\n    a_max = a.max()\n    delta = (a_max - a_min) / bins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\n@numba.jit(nopython=True)\ndef compute_bin(x, bin_edges):\n    # assuming uniform bins for now\n    n = bin_edges.shape[0] - 1\n    a_min = bin_edges[0]\n    a_max = bin_edges[-1]\n\n    # special case to mirror NumPy behavior for last bin\n    if x == a_max:\n        return n - 1 # a_max always in last bin\n\n    bin = int(n * (x - a_min) / (a_max - a_min))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n\n@numba.jit(nopython=True)\ndef numba_histogram(a, bins):\n    hist = np.zeros((bins,), dtype=np.intp)\n    bin_edges = get_bin_edges(a, bins)\n\n    for x in a.flat:\n        bin = compute_bin(x, bin_edges)\n        if bin is not None:\n            hist[int(bin)] += 1\n\n    return hist, bin_edges\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "import numpy as np\n\nimport numba\nfrom numba import cuda\n\n@numba.jit(nopython=True)\ndef compute_bin(x, n, xmin, xmax):\n    # special case to mirror NumPy behavior for last bin\n    if x == xmax:\n        return n - 1 # a_max always in last bin\n\n    # SPEEDTIP: Remove the float64 casts if you don't need to exactly reproduce NumPy\n    bin = np.int32(n * (np.float64(x) - np.float64(xmin)) / (np.float64(xmax) - np.float64(xmin)))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n@cuda.jit\ndef histogram(x, xmin, xmax, histogram_out):\n    nbins = histogram_out.shape[0]\n    bin_width = (xmax - xmin) / nbins\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    for i in range(start, x.shape[0], stride):\n        # note that calling a numba.jit function from CUDA automatically\n        # compiles an equivalent CUDA device function!\n        bin_number = compute_bin(x[i], nbins, xmin, xmax)\n\n        if bin_number >= 0 and bin_number < histogram_out.shape[0]:\n            cuda.atomic.add(histogram_out, bin_number, 1)\n\n@cuda.jit\ndef min_max(x, min_max_array):\n    nelements = x.shape[0]\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    # Array already seeded with starting values appropriate for x's dtype\n    # Not a problem if this array has already been updated\n    local_min = min_max_array[0]\n    local_max = min_max_array[1]\n\n    for i in range(start, x.shape[0], stride):\n        element = x[i]\n        local_min = min(element, local_min)\n        local_max = max(element, local_max)\n\n    # Now combine each thread local min and max\n    cuda.atomic.min(min_max_array, 0, local_min)\n    cuda.atomic.max(min_max_array, 1, local_max)\n\n\ndef dtype_min_max(dtype):\n    '''Get the min and max value for a numeric dtype'''\n    if np.issubdtype(dtype, np.integer):\n        info = np.iinfo(dtype)\n    else:\n        info = np.finfo(dtype)\n    return info.min, info.max\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, nbins, a_min, a_max):\n    bin_edges = np.empty((nbins+1,), dtype=np.float64)\n    delta = (a_max - a_min) / nbins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\ndef numba_gpu_histogram(a, bins):\n    # Move data to GPU so we can do two operations on it\n    a_gpu = cuda.to_device(a)\n\n    ### Find min and max value in array\n    dtype_min, dtype_max = dtype_min_max(a.dtype)\n    # Put them in the array in reverse order so that they will be replaced by the first element in the array\n    min_max_array_gpu = cuda.to_device(np.array([dtype_max, dtype_min], dtype=a.dtype))\n    min_max[64, 64](a_gpu, min_max_array_gpu)\n    a_min, a_max = min_max_array_gpu.copy_to_host()\n\n    # SPEEDTIP: Skip this step if you don't need to reproduce the NumPy histogram edge array\n    bin_edges = get_bin_edges(a, bins, a_min, a_max) # Doing this on CPU for now\n\n    ### Bin the data into a histogram \n    histogram_out = cuda.to_device(np.zeros(shape=(bins,), dtype=np.int32))\n    histogram[64, 64](a_gpu, a_min, a_max, histogram_out)\n\n    return histogram_out.copy_to_host(), bin_edges\n"}], "results": [{"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001496532647870481, 0.0002604799312539399, 0.0012611877219751476, 0.003424849659204483, 0.03461636952124536]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.630304898135364e-06, 5.6507567316293714e-05, 0.0005558006349019706, 0.001662352280691266, 0.016719844285398723]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.001037006853148341, 0.0011961288237944245, 0.0012658769590780138, 0.0018849798198789357, 0.00489949235226959]}, "category": ["bins10", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00014536504074931145, 0.0002531601912342012, 0.0013107356708496809, 0.0035842277901247145, 0.037209007516503335]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.738202488049865e-06, 5.582664292305708e-05, 0.00055030003702268, 0.0016483401972800494, 0.016674925619736315]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00125184983946383, 0.0012505732895806432, 0.0014948898414149881, 0.0020275517785921693, 0.007007238869555295]}, "category": ["bins10", "float64"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00016954931523650884, 0.0002719375449232757, 0.0012725752126425505, 0.003435290795750916, 0.03474489278160035]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.890320774167776e-06, 5.932133109308779e-05, 0.0005829803887754679, 0.0017258191527798773, 0.01742390519939363]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012102787801995874, 0.0013621742324903608, 0.0013998170895501972, 0.001947432761080563, 0.004477115832269191]}, "category": ["bins1000", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015669972682371737, 0.00026460730191320183, 0.001323502161540091, 0.0036235627671703696, 0.037296768324449656]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.979815700091422e-06, 5.900182132609189e-05, 0.0005589674650691449, 0.0016650629602372646, 0.017431940976530315]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0013503633113577961, 0.0013609453197568654, 0.001606761901639402, 0.0021094029722735284, 0.006554908729158342]}, "category": ["bins1000", "float64"]}]}
{"name": "Histogram", "description": "Compute a 1D histogram over elements from an input array.  Note that these\nNumba implementations do not cover all the options that numpy.histogram allows.\n", "created": "2017-07-14T13:11:11.648138", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_histogram(a, bins):\n    return np.histogram(a, bins)\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, bins):\n    bin_edges = np.zeros((bins+1,), dtype=np.float64)\n    a_min = a.min()\n    a_max = a.max()\n    delta = (a_max - a_min) / bins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\n@numba.jit(nopython=True)\ndef compute_bin(x, bin_edges):\n    # assuming uniform bins for now\n    n = bin_edges.shape[0] - 1\n    a_min = bin_edges[0]\n    a_max = bin_edges[-1]\n\n    # special case to mirror NumPy behavior for last bin\n    if x == a_max:\n        return n - 1 # a_max always in last bin\n\n    bin = int(n * (x - a_min) / (a_max - a_min))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n\n@numba.jit(nopython=True)\ndef numba_histogram(a, bins):\n    hist = np.zeros((bins,), dtype=np.intp)\n    bin_edges = get_bin_edges(a, bins)\n\n    for x in a.flat:\n        bin = compute_bin(x, bin_edges)\n        if bin is not None:\n            hist[int(bin)] += 1\n\n    return hist, bin_edges\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "import numpy as np\n\nimport numba\nfrom numba import cuda\n\n@numba.jit(nopython=True)\ndef compute_bin(x, n, xmin, xmax):\n    # special case to mirror NumPy behavior for last bin\n    if x == xmax:\n        return n - 1 # a_max always in last bin\n\n    # SPEEDTIP: Remove the float64 casts if you don't need to exactly reproduce NumPy\n    bin = np.int32(n * (np.float64(x) - np.float64(xmin)) / (np.float64(xmax) - np.float64(xmin)))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n@cuda.jit\ndef histogram(x, xmin, xmax, histogram_out):\n    nbins = histogram_out.shape[0]\n    bin_width = (xmax - xmin) / nbins\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    for i in range(start, x.shape[0], stride):\n        # note that calling a numba.jit function from CUDA automatically\n        # compiles an equivalent CUDA device function!\n        bin_number = compute_bin(x[i], nbins, xmin, xmax)\n\n        if bin_number >= 0 and bin_number < histogram_out.shape[0]:\n            cuda.atomic.add(histogram_out, bin_number, 1)\n\n@cuda.jit\ndef min_max(x, min_max_array):\n    nelements = x.shape[0]\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    # Array already seeded with starting values appropriate for x's dtype\n    # Not a problem if this array has already been updated\n    local_min = min_max_array[0]\n    local_max = min_max_array[1]\n\n    for i in range(start, x.shape[0], stride):\n        element = x[i]\n        local_min = min(element, local_min)\n        local_max = max(element, local_max)\n\n    # Now combine each thread local min and max\n    cuda.atomic.min(min_max_array, 0, local_min)\n    cuda.atomic.max(min_max_array, 1, local_max)\n\n\ndef dtype_min_max(dtype):\n    '''Get the min and max value for a numeric dtype'''\n    if np.issubdtype(dtype, np.integer):\n        info = np.iinfo(dtype)\n    else:\n        info = np.finfo(dtype)\n    return info.min, info.max\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, nbins, a_min, a_max):\n    bin_edges = np.empty((nbins+1,), dtype=np.float64)\n    delta = (a_max - a_min) / nbins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\ndef numba_gpu_histogram(a, bins):\n    # Move data to GPU so we can do two operations on it\n    a_gpu = cuda.to_device(a)\n\n    ### Find min and max value in array\n    dtype_min, dtype_max = dtype_min_max(a.dtype)\n    # Put them in the array in reverse order so that they will be replaced by the first element in the array\n    min_max_array_gpu = cuda.to_device(np.array([dtype_max, dtype_min], dtype=a.dtype))\n    min_max[64, 64](a_gpu, min_max_array_gpu)\n    a_min, a_max = min_max_array_gpu.copy_to_host()\n\n    # SPEEDTIP: Skip this step if you don't need to reproduce the NumPy histogram edge array\n    bin_edges = get_bin_edges(a, bins, a_min, a_max) # Doing this on CPU for now\n\n    ### Bin the data into a histogram \n    histogram_out = cuda.to_device(np.zeros(shape=(bins,), dtype=np.int32))\n    histogram[64, 64](a_gpu, a_min, a_max, histogram_out)\n\n    return histogram_out.copy_to_host(), bin_edges\n"}], "results": [{"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001505055553279817, 0.00026203742856159806, 0.0012588059389963746, 0.003407506151124835, 0.03407710483297706]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.55558351892978e-06, 5.638822331093252e-05, 0.0005514190406538546, 0.0016655044676735997, 0.01672255080193281]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012730942899361252, 0.0012722733477130532, 0.0013421985320746898, 0.001975455619394779, 0.0049563952488824725]}, "category": ["bins10", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00014648230280727147, 0.00025720196682959797, 0.0013089236337691546, 0.003554029129445553, 0.03661643671803176]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.715392768383026e-06, 5.597071847878396e-05, 0.0005502316439524293, 0.001649464168585837, 0.016670382162556053]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012619607197120785, 0.001269474891014397, 0.0015296645183116198, 0.002075291890650988, 0.007110645798966289]}, "category": ["bins10", "float64"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00016775592882186174, 0.0002712993356399238, 0.001268395520746708, 0.003422217033803463, 0.034018256887793544]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.946252590045332e-06, 5.779989128932357e-05, 0.0005644531641155481, 0.0016790410690009595, 0.016831827675923706]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012153821205720305, 0.001373528903350234, 0.0014284922694787383, 0.0019850664632394908, 0.00453998242970556]}, "category": ["bins1000", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015697097219526769, 0.00026688528480008246, 0.0013059153873473406, 0.003555719167925417, 0.036714745499193666]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.910556527785956e-06, 5.724296420812607e-05, 0.0005613017431460321, 0.001665020789951086, 0.016795316711068153]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0013722294988110662, 0.001384442150592804, 0.0016366684483364224, 0.0021654317062348126, 0.006679806169122457]}, "category": ["bins1000", "float64"]}]}
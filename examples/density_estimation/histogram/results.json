{"name": "Histogram", "description": "Compute a 1D histogram over elements from an input array.  Note that these\nNumba implementations do not cover all the options that numpy.histogram allows.\n", "created": "2017-07-15T16:19:25.910584", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_histogram(a, bins):\n    return np.histogram(a, bins)\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, bins):\n    bin_edges = np.zeros((bins+1,), dtype=np.float64)\n    a_min = a.min()\n    a_max = a.max()\n    delta = (a_max - a_min) / bins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\n@numba.jit(nopython=True)\ndef compute_bin(x, bin_edges):\n    # assuming uniform bins for now\n    n = bin_edges.shape[0] - 1\n    a_min = bin_edges[0]\n    a_max = bin_edges[-1]\n\n    # special case to mirror NumPy behavior for last bin\n    if x == a_max:\n        return n - 1 # a_max always in last bin\n\n    bin = int(n * (x - a_min) / (a_max - a_min))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n\n@numba.jit(nopython=True)\ndef numba_histogram(a, bins):\n    hist = np.zeros((bins,), dtype=np.intp)\n    bin_edges = get_bin_edges(a, bins)\n\n    for x in a.flat:\n        bin = compute_bin(x, bin_edges)\n        if bin is not None:\n            hist[int(bin)] += 1\n\n    return hist, bin_edges\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "import numpy as np\n\nimport numba\nfrom numba import cuda\n\n@numba.jit(nopython=True)\ndef compute_bin(x, n, xmin, xmax):\n    # special case to mirror NumPy behavior for last bin\n    if x == xmax:\n        return n - 1 # a_max always in last bin\n\n    # SPEEDTIP: Remove the float64 casts if you don't need to exactly reproduce NumPy\n    bin = np.int32(n * (np.float64(x) - np.float64(xmin)) / (np.float64(xmax) - np.float64(xmin)))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n@cuda.jit\ndef histogram(x, xmin, xmax, histogram_out):\n    nbins = histogram_out.shape[0]\n    bin_width = (xmax - xmin) / nbins\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    for i in range(start, x.shape[0], stride):\n        # note that calling a numba.jit function from CUDA automatically\n        # compiles an equivalent CUDA device function!\n        bin_number = compute_bin(x[i], nbins, xmin, xmax)\n\n        if bin_number >= 0 and bin_number < histogram_out.shape[0]:\n            cuda.atomic.add(histogram_out, bin_number, 1)\n\n@cuda.jit\ndef min_max(x, min_max_array):\n    nelements = x.shape[0]\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    # Array already seeded with starting values appropriate for x's dtype\n    # Not a problem if this array has already been updated\n    local_min = min_max_array[0]\n    local_max = min_max_array[1]\n\n    for i in range(start, x.shape[0], stride):\n        element = x[i]\n        local_min = min(element, local_min)\n        local_max = max(element, local_max)\n\n    # Now combine each thread local min and max\n    cuda.atomic.min(min_max_array, 0, local_min)\n    cuda.atomic.max(min_max_array, 1, local_max)\n\n\ndef dtype_min_max(dtype):\n    '''Get the min and max value for a numeric dtype'''\n    if np.issubdtype(dtype, np.integer):\n        info = np.iinfo(dtype)\n    else:\n        info = np.finfo(dtype)\n    return info.min, info.max\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, nbins, a_min, a_max):\n    bin_edges = np.empty((nbins+1,), dtype=np.float64)\n    delta = (a_max - a_min) / nbins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\ndef numba_gpu_histogram(a, bins):\n    # Move data to GPU so we can do two operations on it\n    a_gpu = cuda.to_device(a)\n\n    ### Find min and max value in array\n    dtype_min, dtype_max = dtype_min_max(a.dtype)\n    # Put them in the array in reverse order so that they will be replaced by the first element in the array\n    min_max_array_gpu = cuda.to_device(np.array([dtype_max, dtype_min], dtype=a.dtype))\n    min_max[64, 64](a_gpu, min_max_array_gpu)\n    a_min, a_max = min_max_array_gpu.copy_to_host()\n\n    # SPEEDTIP: Skip this step if you don't need to reproduce the NumPy histogram edge array\n    bin_edges = get_bin_edges(a, bins, a_min, a_max) # Doing this on CPU for now\n\n    ### Bin the data into a histogram \n    histogram_out = cuda.to_device(np.zeros(shape=(bins,), dtype=np.int32))\n    histogram[64, 64](a_gpu, a_min, a_max, histogram_out)\n\n    return histogram_out.copy_to_host(), bin_edges\n"}], "results": [{"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015087303519248962, 0.00026578909205272796, 0.0012815962685272097, 0.0034501386573538182, 0.034835335426032545]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.663530920632183e-06, 5.5874007381498815e-05, 0.0005557847763411701, 0.001661295290105045, 0.016729313414543867]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0010594809614121914, 0.0012273933319374918, 0.0012950464710593224, 0.0019332581013441087, 0.004987442721612751]}, "category": ["bins10", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00014715087274089455, 0.00025570727000012993, 0.0013093697698786854, 0.0036009240010753275, 0.03740698122419417]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.727806213311851e-06, 5.599727239459753e-05, 0.0005505799599923193, 0.001648311116732657, 0.016674233973026274]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012738052289932966, 0.0012818444287404419, 0.001543251289986074, 0.002081888299435377, 0.007059755600057543]}, "category": ["bins10", "float64"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001694958577863872, 0.00027485633082687856, 0.0012867065519094466, 0.003439998631365597, 0.03493191245943308]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.924899850040675e-06, 5.7062812894582746e-05, 0.0005613054782152175, 0.0016782082011923194, 0.016845729295164348]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012293813563883304, 0.0013986091082915663, 0.0014333150070160628, 0.002004653559997678, 0.004525474538095296]}, "category": ["bins1000", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015629968326538802, 0.0002569016101770103, 0.0013175286026671528, 0.003619342353194952, 0.037558612786233424]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.98650837969035e-06, 5.733112688176334e-05, 0.0005596508681774139, 0.0016649626614525913, 0.01682125381194055]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0013942602975293994, 0.0013920046808198095, 0.0016504495404660701, 0.0021549097495153547, 0.006666071228682995]}, "category": ["bins1000", "float64"]}]}
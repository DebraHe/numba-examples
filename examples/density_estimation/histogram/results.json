{"name": "Histogram", "description": "Compute a 1D histogram over elements from an input array.  Note that these\nNumba implementations do not cover all the options that numpy.histogram allows.\n", "created": "2017-07-17T10:50:44.636535", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef numpy_histogram(a, bins):\n    return np.histogram(a, bins)\n"}, {"name": "numba", "description": "Numba single threaded", "source": "\nimport numba\nimport numpy as np\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, bins):\n    bin_edges = np.zeros((bins+1,), dtype=np.float64)\n    a_min = a.min()\n    a_max = a.max()\n    delta = (a_max - a_min) / bins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\n@numba.jit(nopython=True)\ndef compute_bin(x, bin_edges):\n    # assuming uniform bins for now\n    n = bin_edges.shape[0] - 1\n    a_min = bin_edges[0]\n    a_max = bin_edges[-1]\n\n    # special case to mirror NumPy behavior for last bin\n    if x == a_max:\n        return n - 1 # a_max always in last bin\n\n    bin = int(n * (x - a_min) / (a_max - a_min))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n\n@numba.jit(nopython=True)\ndef numba_histogram(a, bins):\n    hist = np.zeros((bins,), dtype=np.intp)\n    bin_edges = get_bin_edges(a, bins)\n\n    for x in a.flat:\n        bin = compute_bin(x, bin_edges)\n        if bin is not None:\n            hist[int(bin)] += 1\n\n    return hist, bin_edges\n"}, {"name": "numba_gpu", "description": "Numba-compiled CUDA kernel.\n", "source": "import numpy as np\n\nimport numba\nfrom numba import cuda\n\n@numba.jit(nopython=True)\ndef compute_bin(x, n, xmin, xmax):\n    # special case to mirror NumPy behavior for last bin\n    if x == xmax:\n        return n - 1 # a_max always in last bin\n\n    # SPEEDTIP: Remove the float64 casts if you don't need to exactly reproduce NumPy\n    bin = np.int32(n * (np.float64(x) - np.float64(xmin)) / (np.float64(xmax) - np.float64(xmin)))\n\n    if bin < 0 or bin >= n:\n        return None\n    else:\n        return bin\n\n@cuda.jit\ndef histogram(x, xmin, xmax, histogram_out):\n    nbins = histogram_out.shape[0]\n    bin_width = (xmax - xmin) / nbins\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    for i in range(start, x.shape[0], stride):\n        # note that calling a numba.jit function from CUDA automatically\n        # compiles an equivalent CUDA device function!\n        bin_number = compute_bin(x[i], nbins, xmin, xmax)\n\n        if bin_number >= 0 and bin_number < histogram_out.shape[0]:\n            cuda.atomic.add(histogram_out, bin_number, 1)\n\n@cuda.jit\ndef min_max(x, min_max_array):\n    nelements = x.shape[0]\n\n    start = cuda.grid(1)\n    stride = cuda.gridsize(1)\n\n    # Array already seeded with starting values appropriate for x's dtype\n    # Not a problem if this array has already been updated\n    local_min = min_max_array[0]\n    local_max = min_max_array[1]\n\n    for i in range(start, x.shape[0], stride):\n        element = x[i]\n        local_min = min(element, local_min)\n        local_max = max(element, local_max)\n\n    # Now combine each thread local min and max\n    cuda.atomic.min(min_max_array, 0, local_min)\n    cuda.atomic.max(min_max_array, 1, local_max)\n\n\ndef dtype_min_max(dtype):\n    '''Get the min and max value for a numeric dtype'''\n    if np.issubdtype(dtype, np.integer):\n        info = np.iinfo(dtype)\n    else:\n        info = np.finfo(dtype)\n    return info.min, info.max\n\n\n@numba.jit(nopython=True)\ndef get_bin_edges(a, nbins, a_min, a_max):\n    bin_edges = np.empty((nbins+1,), dtype=np.float64)\n    delta = (a_max - a_min) / nbins\n    for i in range(bin_edges.shape[0]):\n        bin_edges[i] = a_min + i * delta\n\n    bin_edges[-1] = a_max  # Avoid roundoff error on last point\n    return bin_edges\n\n\ndef numba_gpu_histogram(a, bins):\n    # Move data to GPU so we can do two operations on it\n    a_gpu = cuda.to_device(a)\n\n    ### Find min and max value in array\n    dtype_min, dtype_max = dtype_min_max(a.dtype)\n    # Put them in the array in reverse order so that they will be replaced by the first element in the array\n    min_max_array_gpu = cuda.to_device(np.array([dtype_max, dtype_min], dtype=a.dtype))\n    min_max[64, 64](a_gpu, min_max_array_gpu)\n    a_min, a_max = min_max_array_gpu.copy_to_host()\n\n    # SPEEDTIP: Skip this step if you don't need to reproduce the NumPy histogram edge array\n    bin_edges = get_bin_edges(a, bins, a_min, a_max) # Doing this on CPU for now\n\n    ### Bin the data into a histogram \n    histogram_out = cuda.to_device(np.zeros(shape=(bins,), dtype=np.int32))\n    histogram[64, 64](a_gpu, a_min, a_max, histogram_out)\n\n    return histogram_out.copy_to_host(), bin_edges\n"}], "results": [{"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00015088853472843767, 0.00026161649078130725, 0.0012807063199579715, 0.0034344953671097754, 0.034661124693229795]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.647593379020691e-06, 5.636753411963582e-05, 0.000556419582106173, 0.0016626338101923465, 0.01673264312557876]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0010499067511409521, 0.001208199691027403, 0.0012810396496206523, 0.0018860903661698104, 0.004872329463250935]}, "category": ["bins10", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001456677191890776, 0.00025323027838021516, 0.001318519259802997, 0.003575164880603552, 0.03724171239882708]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [6.751192179508507e-06, 5.6331178871914744e-05, 0.0005512631838209927, 0.0016479544481262565, 0.016757849138230085]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012584435287863016, 0.001262962226755917, 0.0015099911810830236, 0.0020273999776691197, 0.0070659216307103635]}, "category": ["bins10", "float64"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.00016873162798583508, 0.0002708030939102173, 0.0012718116026371718, 0.0034398266207426786, 0.03498332193121314]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [7.923168689012527e-06, 5.8830914925783875e-05, 0.0005674923514015972, 0.0016837852587923408, 0.016899818601086736]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0012104663392528891, 0.0013587106438353658, 0.001405933047644794, 0.0019528943579643966, 0.004479541261680424]}, "category": ["bins1000", "float32"]}, {"numpy": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0001557303541339934, 0.0002631849548779428, 0.0013192158192396164, 0.003594090668484569, 0.037283852230757475]}, "numba": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [8.632364817894996e-06, 5.941661959514022e-05, 0.000560780253726989, 0.0016731417691335081, 0.0169913224875927]}, "numba_gpu": {"x": [1000, 10000, 100000, 300000, 3000000], "times": [0.0013562988815829157, 0.0013691747933626175, 0.0016020557470619679, 0.0021185022965073586, 0.006665371367707848]}, "category": ["bins1000", "float64"]}]}
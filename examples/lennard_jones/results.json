{"name": "Lennard Jones", "description": "Compute the Lennard Jones Pontential for a random cluster of atoms\nin 3D space of a fixed radius.  This computes sum of all energy potentials\nof every pair of atoms in the cluster.\n", "created": "2017-07-15T16:21:28.787975", "xlabel": "Number of input elements", "baseline": "numpy", "implementations": [{"name": "numpy", "description": "Numpy function", "source": "\nimport numpy as np\n\ndef lj_numpy(r):\n    sr6 = (1./r)**6\n    pot = 4.*(sr6*sr6 - sr6)\n    return pot\n\n\ndef distances_numpy(cluster):\n    diff = cluster[:, np.newaxis, :] - cluster[np.newaxis, :, :]\n    mat = np.sqrt((diff * diff).sum(-1))\n    return mat\n\n\ndef potential_numpy(cluster):\n    d = distances_numpy(cluster)\n    dtri = np.triu(d)\n    energy = lj_numpy(dtri[dtri > 1e-6]).sum()\n    return energy\n"}, {"name": "numba_array", "description": "Numba function operating on mostly array. This is not a fast implementation but is the closest to the *numpy* version.", "source": "import numpy as np\nimport numba\n\n@numba.njit\ndef lj_numba_array(r):\n    sr6 = (1./r)**6\n    pot = 4.*(sr6*sr6 - sr6)\n    return pot\n\n\n@numba.njit\ndef distances_numba_array(cluster):\n    # Original: diff = cluster[:, np.newaxis, :] - cluster[np.newaxis, :, :]\n    # Since np.newaxis is not supported, we use reshape to do this\n    diff = (cluster.reshape(cluster.shape[0], 1, cluster.shape[1]) -\n            cluster.reshape(1, cluster.shape[0], cluster.shape[1]))\n    mat = (diff * diff)\n    # Original: mat = mat.sum(-1)\n    # Since axis argument is not supported, we write the loop out\n    out = np.empty(mat.shape[:2], dtype=mat.dtype)\n    for i in np.ndindex(out.shape):\n        out[i] = mat[i].sum()\n\n    return np.sqrt(out)\n\n\n@numba.njit\ndef potential_numba_array(cluster):\n    d = distances_numba_array(cluster)\n    # Original: dtri = np.triu(d)\n    # np.triu is not supported; so write my own loop to clear the\n    # lower triangle\n    for i in range(d.shape[0]):\n        for j in range(d.shape[1]):\n            if i > j:\n                d[i, j] = 0\n    # Original: lj_numba_array(d[d > 1e-6]).sum()\n    # d[d > 1e-6] is not supported due to the indexing with boolean\n    # array.  Replace with custom loop.\n    energy = 0.0\n    for v in d.flat:\n        if v > 1e-6:\n            energy += lj_numba_array(v)\n    return energy\n"}, {"name": "numba_scalar", "description": "Numba function operating on scalar mostly. This version has the algorithm rewritten to operate on a scalar at a time in manually written loops.", "source": "import numba\n\n@numba.njit\ndef lj_numba_scalar(r):\n    sr6 = (1./r)**6\n    pot = 4.*(sr6*sr6 - sr6)\n    return pot\n\n\n@numba.njit\ndef distance_numba_scalar(atom1, atom2):\n    dx = atom2[0] - atom1[0]\n    dy = atom2[1] - atom1[1]\n    dz = atom2[2] - atom1[2]\n\n    r = (dx * dx + dy * dy + dz * dz) ** 0.5\n\n    return r\n\n\n@numba.njit\ndef potential_numba_scalar(cluster):\n    energy = 0.0\n    for i in range(len(cluster)-1):\n        for j in range(i + 1, len(cluster)):\n            r = distance_numba_scalar(cluster[i], cluster[j])\n            e = lj_numba_scalar(r)\n            energy += e\n\n    return energy\n"}, {"name": "numba_scalar_prange", "description": "This enables the *prange* feature on *numba_scalar*.", "source": "import numba\n\n@numba.njit\ndef lj_numba_scalar_prange(r):\n    sr6 = (1./r)**6\n    pot = 4.*(sr6*sr6 - sr6)\n    return pot\n\n\n@numba.njit\ndef distance_numba_scalar_prange(atom1, atom2):\n    dx = atom2[0] - atom1[0]\n    dy = atom2[1] - atom1[1]\n    dz = atom2[2] - atom1[2]\n\n    r = (dx * dx + dy * dy + dz * dz) ** 0.5\n\n    return r\n\n\n@numba.njit(parallel=True)\ndef potential_numba_scalar_prange(cluster):\n    energy = 0.0\n    # numba.prange requires parallel=True flag to compile.\n    # It causes the loop to run in parallel in multiple threads.\n    for i in numba.prange(len(cluster)-1):\n        for j in range(i + 1, len(cluster)):\n            r = distance_numba_scalar_prange(cluster[i], cluster[j])\n            e = lj_numba_scalar_prange(r)\n            energy += e\n\n    return energy\n"}], "results": [{"numpy": {"x": [100, 500, 1000, 1500, 2000], "times": [0.0007177451220341027, 0.016797557519748808, 0.068410599604249, 0.16494283778592944, 0.2910615364089608]}, "numba_array": {"x": [100, 500, 1000, 1500, 2000], "times": [0.0004961407086811959, 0.012364592496305704, 0.04959443900734186, 0.11970234801992774, 0.21640798775479198]}, "numba_scalar": {"x": [100, 500, 1000, 1500, 2000], "times": [4.1920475708320736e-05, 0.0010082804970443248, 0.0040371875371783975, 0.009059998067095875, 0.0172422697301954]}, "numba_scalar_prange": {"x": [100, 500, 1000, 1500, 2000], "times": [3.282535709440708e-05, 0.00036745210783556106, 0.0012379917316138744, 0.003017661771737039, 0.005753793250769377]}, "category": ["float64"]}]}